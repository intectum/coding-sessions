debug = import("core/debug")
memory = import("core/memory") // TODO needed for allocators to work
linux = import("core/os/linux")
strings = import("core/strings")
threading = import("core/threading")

glfw = import("vendor/glfw")
gl = import("vendor/gl")
glu = import("vendor/glu")

glfw.glfwInit()
window = glfw.glfwCreateWindow(1920, 1080, "Bangalang", nil, nil)
glfw.glfwMakeContextCurrent(window)
glfw.glfwSwapInterval(0)

vertex_shader_src: cstring = "#version 460 core\nin vec3 position; void main() { gl_Position = vec4(position, 1.0); }"
vertex_shader_src_len: i32 = 86
vertex_shader_name = compile_shader(gl.GL_VERTEX_SHADER, vertex_shader_src, vertex_shader_src_len)

fragment_shader_src: cstring = "#version 460 core\nout vec4 color; void main() { color = vec4(1.0); }"
fragment_shader_src_len: i32 = 86
fragment_shader_name = compile_shader(gl.GL_FRAGMENT_SHADER, fragment_shader_src, fragment_shader_src_len)

program_name = link_shaders(vertex_shader_name, fragment_shader_name)

triangle_count_1d: i64 = 64
triangle_count = triangle_count_1d * triangle_count_1d
triangle_size = 2 / f32(triangle_count_1d)
vertex_count = triangle_count * 3

buffer_data: ^threading.vec3[12288]@vram

vertex_index: i64
for x: i64, x < triangle_count_1d, x += 1
{
    for y: i64, y < triangle_count_1d, y += 1
    {
        left = -1 + triangle_size * f32(x)
        bottom = -1 + triangle_size * f32(y)

        buffer_data[vertex_index][0] = left + triangle_size * 0.5
        buffer_data[vertex_index][1] = bottom + triangle_size
        buffer_data[vertex_index][2] = 0
        vertex_index += 1

        buffer_data[vertex_index][0] = left
        buffer_data[vertex_index][1] = bottom
        buffer_data[vertex_index][2] = 0
        vertex_index += 1

        buffer_data[vertex_index][0] = left + triangle_size
        buffer_data[vertex_index][1] = bottom
        buffer_data[vertex_index][2] = 0
        vertex_index += 1
    }
}

gl.glUseProgram(program_name) check_opengl_error()

gl.glEnableVertexAttribArray(0) check_opengl_error()
gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, false, 0, nil) check_opengl_error()

fps_timeval: i64[2]
linux.gettimeofday(^fps_timeval)
fps_time = fps_timeval[0] * 1000000 + fps_timeval[1]
frame_count: i64

task_func: proc(data: threading.vec3[], start: i64) =
{
    delta: threading.vec3
    delta[0] = 0.001
    delta[1] = 0.001
    delta[2] = 0

    for index: i64, index < data.length, index += 1
    {
        data[index] += delta
    }
}

pool: threading.thread_pool = { worker_count = 8 }
threading.thread_pool_start(^pool)

for glfw.glfwWindowShouldClose(window) == 0
{
    glfw.glfwPollEvents()
    glfw.glfwSwapBuffers(window)

    //task_func(buffer_data[:], 0)

    threading.boomstick(^pool, task_func, buffer_data[:])
    threading.thread_pool_wait(^pool)

    gl.glClear(gl.GL_COLOR_BUFFER_BIT) check_opengl_error()
    gl.glDrawArrays(gl.GL_TRIANGLES, 0, i32(vertex_count)) check_opengl_error()

    timeval: i64[2]
    linux.gettimeofday(^timeval)
    time = timeval[0] * 1000000 + timeval[1]
    if time > fps_time + 1000000
    {
        string_buf: i8[100]
        strings.print("FPS: ")
        strings.println(strings.itoa(frame_count, string_buf[:]))

        frame_count = 0
        fps_time = time
    }

    frame_count += 1
}

compile_shader: proc(type: i32, src: cstring, src_len: i32) -> i32 =
{
    name = gl.glCreateShader(type) check_opengl_error()
    gl.glShaderSource(name, 1, ^src, ^src_len) check_opengl_error()
    gl.glCompileShader(name) check_opengl_error()

    compile_status: i32
    gl.glGetShaderiv(name, gl.GL_COMPILE_STATUS, ^compile_status) check_opengl_error()

    info_log: i8[1000000]
    info_log_length: i32
    gl.glGetShaderInfoLog(name, i32(info_log.length), ^info_log_length, info_log.raw) check_opengl_error()

    if info_log[0] != 0 strings.println(info_log[:info_log_length])
    debug.assert(compile_status != 0, "failed to compile shader")

    return name
}

link_shaders: proc(vertex_shader_name: i32, fragment_shader_name: i32) -> i32 =
{
    name = gl.glCreateProgram() check_opengl_error()
    gl.glAttachShader(name, vertex_shader_name) check_opengl_error()
    gl.glAttachShader(name, fragment_shader_name) check_opengl_error()
    gl.glLinkProgram(name) check_opengl_error()

    link_status: i32
    gl.glGetProgramiv(name, gl.GL_LINK_STATUS, ^link_status) check_opengl_error()

    info_log: i8[1000000]
    info_log_length: i32
    gl.glGetProgramInfoLog(name, i32(info_log.length), ^info_log_length, info_log.raw) check_opengl_error()

    if info_log[0] != 0 strings.println(info_log[:info_log_length])
    debug.assert(link_status != 0, "failed to link shaders")

    return name
}

check_opengl_error: proc() =
{
    error = gl.glGetError()
    if error != gl.GL_NO_ERROR
    {
        error_buffer = glu.gluErrorString(error)
        strings.println({ raw = error_buffer, length = 100 })
    }
}
