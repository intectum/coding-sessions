threading = import("core/threading")
memory = import("core/memory")

gl = import("vendor/gl")

kernel_t = proc(index: i32, data: threading.vec4[])

pool: threading.thread_pool@static = { worker_count = 8 } // TODO query core count from kernel
threading.thread_pool_start(^pool)

// TODO proper map?!
glsl_kernels: (^string)[]@none
glsl_kernel_names: i32[100]@static

init: proc() =
{
  for index: i64, index < glsl_kernels.length, index += 1
  {
    name = gl.glCreateProgram()
    shader_name = gl.glCreateShader(gl.GL_COMPUTE_SHADER)
    gl.glShaderSource(shader_name, 1, ^glsl_kernels[index].raw, ^i32(glsl_kernels[index].length))
    gl.glCompileShader(shader_name)
    gl.glAttachShader(name, shader_name)
    gl.glLinkProgram(name)
    glsl_kernel_names[index] = name
  }
}

bang: proc(kernel: kernel_t, data: threading.vec4[]) =
{
  for kernel_index: i64, kernel_index < glsl_kernels.length, kernel_index += 1
  {
    if kernel == #untyped glsl_kernels[kernel_index]
    {
      gl.glUseProgram(glsl_kernel_names[kernel_index])

      for buffer_index: i64, buffer_index < memory.vram_allocator_addresses.length, buffer_index += 1
      {
        if data.raw == #untyped memory.vram_allocator_addresses[buffer_index]
        {
          gl.glBindBufferBase(gl.GL_SHADER_STORAGE_BUFFER, 0, memory.vram_allocator_names[buffer_index])
        }
      }

      gl.glDispatchCompute(i32(data.length / 64), 1, 1)

      return
    }
  }

  worker_data_length = i32(data.length) / pool.worker_count

  for index: i32, index < pool.worker_count, index += 1
  {
    start = index * worker_data_length
    end = start + worker_data_length

    task: threading.thread_pool_task =
    {
      func = kernel,
      start = start,
      end = end,
      data = data
    }

    threading.thread_pool_enqueue(^pool, ^task)
  }

  threading.thread_pool_wait(^pool) // TODO we probably don't always want to wait...
}
