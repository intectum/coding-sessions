linux: = import("os/linux")
os: = import("os")
strings: = import("strings")

mutex_lock: proc(mutex: ^i32) =
  do for !cmpxchg(mutex, 0, 1)
    do linux.futex_wait(mutex, 1, 0)

mutex_unlock: proc(mutex: ^i32) =
  do if cmpxchg(mutex, 1, 0)
    do linux.futex_wake(mutex, 1)

semaphore_t: = struct
{
  value: atomic_i32,
  waiter: i32
}

semaphore_wait: proc(semaphore: ^semaphore_t) =
  do for true
  {
    semaphore.value -= 1
    if semaphore.value >= 0 do return
    semaphore.value += 1
    linux.futex_wait(^semaphore.waiter, 0, 0)
  }

semaphore_signal: proc(semaphore: ^semaphore_t) =
{
  semaphore.value += 1
  linux.futex_wake(^semaphore.waiter, 1)
}

start_thread: proc(func: proc(param: $T), param: $T) -> i64 =
{
  stack: byte[4096]@os.heap
  stack_ptr := stack.length

  stack_ptr -= (^byte).size
  stack_func: ^proc(param: $T) = #danger_untyped ^stack[stack_ptr]
  stack_func^ = func

  stack_ptr -= $T.size
  stack_param: ^$T = #danger_untyped ^stack[stack_ptr]
  stack_param^ = param

  stack_ptr -=
    (^byte).size + // instruction pointer
    byte[].size + // stack
    i64.size + // stack_ptr
    (^byte).size + // stack_func
    (^byte).size + // stack_param
    i64.size // stack_param

  pid: = linux.syscall(56, linux.CLONE_VM | linux.CLONE_FILES | linux.CLONE_SIGHAND | linux.CLONE_THREAD, #danger_untyped ^stack[stack_ptr], 0, 0, 0, 0)

  if pid == 0
  {
    func(param)
    linux.exit(0)
  }

  return pid
}

thread_pool_task_t: = struct
{
  func: proc(index: i32, data: vec4[]),
  start: i32,
  end: i32,
  data: vec4[]
}

thread_pool_t: = #align4 struct
{
  worker_count: i32,
  current_worker_count: i32,
  tasks: thread_pool_task_t[100],
  task_count: i32,
  mutex: i32,
  semaphore: semaphore_t,
  working: i32
}

thread_pool_worker: proc(param: ^thread_pool_t) =
{
  alive: = true
  for alive
  {
    semaphore_wait(^param.semaphore)
    mutex_lock(^param.mutex)

    if param.task_count == 0
    {
      alive = false
      mutex_unlock(^param.mutex)
    }
    else
    {
      param.current_worker_count += 1
      param.task_count -= 1
      task: = param.tasks[param.task_count]
      mutex_unlock(^param.mutex)

      for index: = task.start, index < task.end, index += 1
        do task.func(index, task.data)

      mutex_lock(^param.mutex)
      param.current_worker_count -= 1
      if param.task_count == 0 && param.current_worker_count == 0
      {
        param.working = 0
        linux.futex_wake(^param.working, 999 /* TODO i64.max */)
      }
      mutex_unlock(^param.mutex)
    }
  }
}

thread_pool_start: proc(pool: ^thread_pool_t) =
  do for index: i32, index < pool.worker_count, index += 1
    do start_thread(thread_pool_worker, pool)

thread_pool_enqueue: proc(pool: ^thread_pool_t, task: ^thread_pool_task_t) =
{
  mutex_lock(^pool.mutex)
  pool.tasks[pool.task_count] = task^
  pool.task_count += 1
  pool.working = 1
  mutex_unlock(^pool.mutex)

  semaphore_signal(^pool.semaphore)
}

thread_pool_wait: proc(pool: ^thread_pool_t) =
  do linux.futex_wait(^pool.working, 1, 0)

thread_pool_stop: proc(pool: ^thread_pool_t) =
  do for index: i32, index < pool.worker_count, index += 1
    do semaphore_signal(^pool.semaphore)

get_cpu_core_count: proc() -> u8 =
{
  cpuinfo: = linux.open("/proc/cpuinfo", linux.O_RDONLY)
  buffer: byte[1000]
  read_count: = linux.read(cpuinfo, buffer.raw, buffer.length)

  cpu_cores_prefix: = "cpu cores\t: "
  for index: i64, index < read_count - cpu_cores_prefix.length, index += 1
  {
    if buffer[index:index + cpu_cores_prefix.length] == cpu_cores_prefix
    {
      core_count_string: = buffer[index + cpu_cores_prefix.length:index + cpu_cores_prefix.length + 1]
      return u8(strings.atoi(core_count_string))
    }
  }

  return 1
}
