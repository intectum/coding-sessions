linux: = import("core/os/linux")
strings: = import("core/strings")

mutex_lock: proc(mutex: ^i32) =
  for !cmpxchg(mutex, 0, 1)
    linux.futex(mutex, 0 /* FUTEX_WAIT */, 1 /* expected */, 0 /* timeout */)

mutex_unlock: proc(mutex: ^i32) =
  if cmpxchg(mutex, 1, 0)
    linux.futex(mutex, 1 /* FUTEX_WAKE */, 1 /* count */, 0)

semaphore_t: = struct
{
  value: atomic_i32,
  waiter: i32
}

semaphore_wait: proc(semaphore: ^semaphore_t) =
  for true
  {
    semaphore.value -= 1
    if semaphore.value >= 0 return
    semaphore.value += 1
    linux.futex(^semaphore.waiter, 0 /* FUTEX_WAIT */, 0 /* expected */, 0 /* timeout */)
  }

semaphore_signal: proc(semaphore: ^semaphore_t) =
{
  semaphore.value += 1
  linux.futex(^semaphore.waiter, 1 /* FUTEX_WAKE */, 1 /* count */, 0)
}

start_thread: proc(func: proc(arg: i64), arg: i64) -> i64 =
{
  stack: = linux.mmap(nil, 4096, linux.PROT_READ | linux.PROT_WRITE, linux.MAP_PRIVATE | linux.MAP_ANONYMOUS, -1, 0)

  stack_i64: i64 = #untyped stack
  stack_i64 += 4096
  stack_i64 -= 2 * 8 // account for params
  stack_params: ^i64[2] = #untyped stack_i64
  stack_params[1] = #untyped func
  stack_params[0] = arg
  stack_i64 -= 8 // account for instruction pointer
  stack_i64 -= 5 * 8 // account for local vars declared before clone

  pid: = linux.syscall(56, linux.CLONE_VM | linux.CLONE_FILES | linux.CLONE_SIGHAND | linux.CLONE_THREAD, stack_i64, 0, 0, 0, 0)

  if pid == 0
  {
    func(arg)
    linux.exit(0)
  }

  return pid
}

thread_pool_task_t: = struct
{
  func: proc(index: i32, data: vec4[]),
  start: i32,
  end: i32,
  data: vec4[]
}

thread_pool_t: = struct
{
  worker_count: i32,
  current_worker_count: i32,
  tasks: thread_pool_task_t[100],
  task_count: i32,
  mutex: i32,
  semaphore: semaphore_t,
  working: i32
}

thread_pool_worker: proc(arg: i64) =
{
  pool: ^thread_pool_t = #untyped arg

  alive: = true
  for alive
  {
    semaphore_wait(^pool.semaphore)
    mutex_lock(^pool.mutex)

    if pool.task_count == 0
    {
      alive = false
      mutex_unlock(^pool.mutex)
    }
    else
    {
      pool.current_worker_count += 1
      pool.task_count -= 1
      task: = pool.tasks[pool.task_count]
      mutex_unlock(^pool.mutex)

      for index: = task.start, index < task.end, index += 1
        task.func(index, task.data)

      mutex_lock(^pool.mutex)
      pool.current_worker_count -= 1
      if pool.task_count == 0 && pool.current_worker_count == 0
      {
        pool.working = 0
        linux.futex(^pool.working, 1 /* FUTEX_WAKE */, 999 /* count TODO i64.max */, 0)
      }
      mutex_unlock(^pool.mutex)
    }
  }
}

thread_pool_start: proc(pool: ^thread_pool_t) =
  for index: i32, index < pool.worker_count, index += 1
    start_thread(thread_pool_worker, #untyped pool)

thread_pool_enqueue: proc(pool: ^thread_pool_t, task: ^thread_pool_task_t) =
{
  mutex_lock(^pool.mutex)
  pool.tasks[pool.task_count] = task^
  pool.task_count += 1
  pool.working = 1
  mutex_unlock(^pool.mutex)

  semaphore_signal(^pool.semaphore)
}

thread_pool_wait: proc(pool: ^thread_pool_t) =
  linux.futex(^pool.working, 0 /* FUTEX_WAIT */, 1 /* expected */, 0 /* timeout */)

thread_pool_stop: proc(pool: ^thread_pool_t) =
  for index: i32, index < pool.worker_count, index += 1
    semaphore_signal(^pool.semaphore)
